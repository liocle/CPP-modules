#include <iostream>
#include "Animal.hpp"

Animal::Animal() : _type("Generic Animal") {
    std::cout << "Animal constructor called for " << _type << std::endl;
}

Animal::~Animal() {
    std::cout << "Animal destructor called for " << _type << std::endl;
}

Animal::Animal( Animal const & other ) : _type(other._type) {
    std::cout << "Animal copy constructor called for " << _type << std::endl;
    return;
}

Animal &    Animal::operator=(Animal const & other) {
    std::cout << "Animal assignment operator called for " << _type << std::endl;
    if ( this != &other ){
        this->_type = other.getType();
    }
    return *this;
}

void Animal::makeSound() const {
    std::cout << "Meta animal sound" << std::endl;
}

std::string Animal::getType() const {
    return _type;
}

#ifndef ANIMAL_HPP
#define ANIMAL_HPP

#include <string>

class Animal {
public:
    Animal();
    Animal( Animal const & src );
    Animal &    operator=( Animal const & rhs);

    virtual ~Animal();

    virtual void makeSound() const;
    std::string getType() const;

protected:
    std::string _type;
};

#endif


#include "Brain.hpp"
#include <iostream>
#include <string>

Brain::Brain() { std::cout << "Brain constructor called" << std::endl; }

Brain::~Brain() { std::cout << "Brain destructor called" << std::endl; }

Brain::Brain(const Brain &other) {
    std::cout << "Brain copy contructor using deep copy" << std::endl;
    for (int i = 0; i < 100; i++) {
        _ideas[i] = other._ideas[i];
    }
}

Brain &Brain::operator=(Brain const &other) {
    std::cout << "Brain assignment operator using deep copy" << std::endl;
    if (this != &other) {
        for (int i = 0; i < 100; i++) {
            _ideas[i] = other._ideas[i];
        }
    }
    return *this;
}

void Brain::setIdea(unsigned int index, const std::string &idea) {
    if (index < 100) {
        _ideas[index] = idea;
    }
}

std::string Brain::getIdea(int index) const {
    if (index < 100)
        return (_ideas[index]);
    return ("Not a valid index");
}


#ifndef BRAIN_HPP
# define BRAIN_HPP

# include <string>

class Brain {
public:
    Brain();
    ~Brain();
    Brain( Brain const & src);
    Brain&  operator=( Brain const & rhs );

    void setIdea(unsigned int index, const std::string& idea);
    std::string getIdea(int index) const;

private:
    std::string _ideas[100];
};

#endif
#include "Cat.hpp"
#include <iostream>

Cat::Cat() : Animal() {
    _type = "Cat";
    std::cout << "Cat constructor called" << std::endl;
}

Cat::Cat( Cat const & src ) : Animal(src) {
    std::cout << "Cat copy constructor called for " << _type << std::endl;
}

Cat::~Cat() {
    std::cout << "Cat destructor called" << std::endl;
    delete _brain;
}

Cat &    Cat::operator=(Cat const & rhs) {
    std::cout << "Cat assignment operator called for " << _type << std::endl;
    if ( this != &rhs ){
        this->_type = rhs.getType();
        delete _brain;
        _brain = new Brain(*rhs._brain);
    }
    return *this;
}

void Cat::makeSound() const {
    std::cout << "Miaou! Miaou!" << std::endl;
}

#ifndef CAT_HPP
#define CAT_HPP

#include "Animal.hpp"
#include "Brain.hpp"

class Cat : public Animal {
public:
    Cat();
    virtual ~Cat();
    Cat( Cat const & src ) ;  

    Cat &   operator=( Cat const & rhs);

    void makeSound() const ;

private:
    Brain *_brain;
};

#endif

#include "Dog.hpp"
#include <iostream>

Dog::Dog() : Animal() {
    _type = "Dog";
    std::cout << "Dog constructor called" << std::endl;
}

Dog::Dog(Dog const &src) : Animal(src) {
    std::cout << "Dog copy constructor called for " << _type << std::endl;
}

Dog::~Dog() {
    std::cout << "Dog destructor called" << std::endl; 
    delete _brain;
}

Dog &Dog::operator=(Dog const &rhs) {
    std::cout << "Dog assignment operator called for " << _type << std::endl;
    if (this != &rhs) {
        this->_type = rhs.getType();
        delete _brain;
        _brain = new Brain(*rhs._brain);
    }
    return *this;
}

void Dog::makeSound() const { std::cout << "Ouaf! Ouaf!" << std::endl; }
#ifndef DOG_HPP
#define DOG_HPP

#include "Animal.hpp"
#include "Brain.hpp"

class Dog : public Animal {
public:
    Dog();
    Dog(Dog const & src);

    virtual ~Dog();
    Dog &   operator=(Dog const & rhs);
    void makeSound() const;

private:
    Brain   *_brain;
};

#endif

#include <iostream>
#include "Animal.hpp"
#include "Dog.hpp"
#include "Cat.hpp"
#include "WrongAnimal.hpp"
#include "WrongCat.hpp"
#include "Brain.hpp"

int main() {
    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
    std::cout << "Animal base class's makeSound() is virtual:" << std::endl;
    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
    const Animal* meta = new Animal();
    std::cout << meta->getType() << " says: ";
    meta->makeSound();

    std::cout << "\n" << std::endl;
    const Animal* j = new Dog();
    std::cout << j->getType() << " says: ";
    j->makeSound();

    std::cout << "\n" << std::endl;
    const Animal* i = new Cat();
    std::cout << i->getType() << " says: ";
    i->makeSound(); 


    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
    std::cout << "Additional tests with WrongAnimal's makeSound attribute not being 'virtual'" << std::endl;
    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
    const WrongAnimal* wrongJ = new WrongCat();
    std::cout << wrongJ->getType() << " says: ";
    wrongJ->makeSound(); 

    std::cout <<  std::endl;
    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
    delete meta;
    std::cout << std::endl;
    delete j;
    std::cout << std::endl;
    delete i;
    std::cout << std::endl;
    delete wrongJ;

    return 0;
}

CC      		= 	c++
CFLAGS  		= 	-Wall -Werror -Wextra -std=c++98
CFLAGS_DEBUG 	=	-fsanitize=address,undefined

SRC     		=	main.cpp \
							Animal.cpp \
							Cat.cpp \
							Dog.cpp \
							WrongAnimal.cpp \
							WrongCat.cpp \

OBJ 		    = 	$(SRC:%.cpp=%.o)

NAME		    = 	animal
all: $(NAME)

$(NAME): $(OBJ)
	@echo "Building "  $@ 
	$(CC) $(CFLAGS) -o $(NAME) $(OBJ)

%.o: %.cpp
	$(CC) $(CFLAGS) -c $< -o $@


clean:
	@echo "Cleaning up..."
	/bin/rm -f $(OBJ)

fclean: clean
	@echo "Full cleaning..."
	/bin/rm -f $(NAME)


debug: 	CFLAGS + =$(CFLAGS_DEBUG)
debug:	all

lldb_g: CFLAGS += -g
lldb_g: all

re: 	fclean all

.PHONY: all clean fclean debug lldb re
#include "WrongAnimal.hpp"
#include <iostream>

WrongAnimal::WrongAnimal() : _type("Wrong Generic Animal") {
    std::cout << "WrongAnimal constructor called for " << _type << std::endl;
}

WrongAnimal::WrongAnimal( WrongAnimal const & src ) {
    std::cout << "WrongAnimal copy constructor called for " << _type << std::endl;
    *this = src;
    return;
}

WrongAnimal::~WrongAnimal() {
    std::cout << "WrongAnimal destructor called for " << _type << std::endl;
}

WrongAnimal &    WrongAnimal::operator=(WrongAnimal const & rhs) {
    std::cout << "WrongAnimal assignment operator called for " << _type << std::endl;
    if ( this != &rhs )
        this->_type = rhs.getType();
    return *this;
}

void WrongAnimal::makeSound() const {
    std::cout << "WrongAnimal sound" << std::endl;
}

std::string WrongAnimal::getType() const {
    return _type;
}

#ifndef WRONGANIMAL_HPP
#define WRONGANIMAL_HPP

#include <string>

class WrongAnimal {
protected:
    std::string _type;

public:
    WrongAnimal();
    WrongAnimal(WrongAnimal const & src);
    WrongAnimal & operator=(WrongAnimal const & rhs);

    virtual ~WrongAnimal();
    
    void makeSound() const;
    std::string getType() const;
};

#endif

#include "WrongCat.hpp"
#include <iostream>

WrongCat::WrongCat() : WrongAnimal() {
    _type = "WrongCat";
    std::cout << "WrongCat constructor called" << std::endl;
}

WrongCat::WrongCat(WrongCat const & src) : WrongAnimal(src) {
    std::cout << "WrongCat copy constructor called for " << _type << std::endl;
}

WrongCat &  WrongCat::operator=(WrongCat const & rhs){
    std::cout << "WrongCat assignment operator called for " << _type << std::endl;
    if (this != &rhs) {
       this->_type = rhs.getType(); 
    }
    return *this;
}

WrongCat::~WrongCat() {
    std::cout << "WrongCat destructor called" + _type << std::endl;
}

void WrongCat::makeSound() const {
    std::cout << "Wrong Miaou! Miaou!" << std::endl;
}

#ifndef WRONGCAT_HPP
#define WRONGCAT_HPP

#include "WrongAnimal.hpp"

class WrongCat : public WrongAnimal {
public:
    WrongCat();
    WrongCat(WrongCat const & src);
    WrongCat & operator=(WrongCat const & rhs);
    virtual ~WrongCat();

    void makeSound() const;
};

#endif

